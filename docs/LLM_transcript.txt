## Student Name: Peter Saleeb
## Student ID: 215605322

Prompt 1: 

You are asked to implement a Python function that suggests possible meeting time slots for a given day. The function takes as input a list of existing calendar events for that day and a desired meeting duration. Its goal is to return a list of valid start times at which the meeting could be scheduled. A valid time slot should respect typical working hours and should not conflict with existing events. If no suitable time slots are available, the function should return an empty list. You may assume that time values are provided in a standard string format (e.g., â€œ09:30â€).

from typing import List, Dict

def suggest_slots(
    events: List[Dict[str, str]],
    meeting_duration: int,
    day: str
) -> List[str]:
    """
    Suggest possible meeting start times for a given day.

    Args:
        events: List of dicts with keys {"start": "HH:MM", "end": "HH:MM"}
        meeting_duration: Desired meeting length in minutes
        day: Three-letter day abbreviation (e.g., "Mon", "Tue", ... "Fri")

    Returns:
        List of valid start times as "HH:MM" sorted ascending
    """
    # TODO: Implement this function

finish implementing this function

LLM Response 1: 

Hereâ€™s a clean, reasonable implementation with clear assumptions baked in and documented.

**Assumptions (explicit and common-sense):**

* Working hours are **09:00â€“17:00**.
* Meetings can start on **minute boundaries** (e.g., every minute).
* Only **Monâ€“Fri** are working days; weekends return no slots.
* Events may be unsorted and may touch but not overlap (end == start is OK).

```python
from typing import List, Dict

def suggest_slots(
    events: List[Dict[str, str]],
    meeting_duration: int,
    day: str
) -> List[str]:
    """
    Suggest possible meeting start times for a given day.

    Args:
        events: List of dicts with keys {"start": "HH:MM", "end": "HH:MM"}
        meeting_duration: Desired meeting length in minutes
        day: Three-letter day abbreviation (e.g., "Mon", "Tue", ... "Fri")

    Returns:
        List of valid start times as "HH:MM" sorted ascending
    """

    # Only allow weekdays
    if day not in {"Mon", "Tue", "Wed", "Thu", "Fri"}:
        return []

    WORK_START = 9 * 60    # 09:00
    WORK_END = 17 * 60    # 17:00

    def to_minutes(t: str) -> int:
        h, m = map(int, t.split(":"))
        return h * 60 + m

    def to_time_str(minutes: int) -> str:
        return f"{minutes // 60:02d}:{minutes % 60:02d}"

    # Convert and sort events
    busy_intervals = sorted(
        [(to_minutes(e["start"]), to_minutes(e["end"])) for e in events],
        key=lambda x: x[0]
    )

    available_starts = []

    current_time = WORK_START

    for start, end in busy_intervals:
        # Check if there is free space before this event
        while current_time + meeting_duration <= min(start, WORK_END):
            available_starts.append(to_time_str(current_time))
            current_time += 1  # granularity: 1 minute

        # Move current_time forward if overlapping
        if current_time < end:
            current_time = max(current_time, end)

    # Check remaining time after last event
    while current_time + meeting_duration <= WORK_END:
        available_starts.append(to_time_str(current_time))
        current_time += 1

    return available_starts
```

If you want:

* 15-minute granularity instead of every minute
* configurable working hours
* or support for overlapping / invalid events

say the word and weâ€™ll tweak it.


--------------------------------------------------
Prompt 2: 
please edit the code to do these things: if invalid events given or day given is not today, assume no events if invalid day give, assume today if invalid meeting duration (not int, or > 24*60) return empty list

LLM Response 2: 
Got it â€” hereâ€™s an **edited version of the function** with your new rules applied, while keeping the behavior clear and defensive.

### What changed (plain English)

* **Invalid meeting duration** (not `int` or > 24h) â†’ return `[]`
* **Invalid day string** â†’ assume **today**
* **Day is not today** â†’ assume **no events**
* **Invalid events list** (bad format, bad times, start â‰¥ end, etc.) â†’ assume **no events**
* Still respects **09:00â€“17:00 working hours** and weekdays

---

### Updated implementation

```python
from typing import List, Dict
from datetime import datetime

def suggest_slots(
    events: List[Dict[str, str]],
    meeting_duration: int,
    day: str
) -> List[str]:

    # Validate meeting duration
    if not isinstance(meeting_duration, int) or meeting_duration <= 0 or meeting_duration > 24 * 60:
        return []

    WORK_START = 9 * 60    # 09:00
    WORK_END = 17 * 60    # 17:00
    WEEKDAYS = {"Mon", "Tue", "Wed", "Thu", "Fri"}

    def to_minutes(t: str) -> int:
        h, m = map(int, t.split(":"))
        if not (0 <= h < 24 and 0 <= m < 60):
            raise ValueError
        return h * 60 + m

    def to_time_str(minutes: int) -> str:
        return f"{minutes // 60:02d}:{minutes % 60:02d}"

    # Determine today's day abbreviation
    today = datetime.today().strftime("%a")

    # If invalid day provided, assume today
    if day not in WEEKDAYS:
        day = today

    # If day is not today, assume no events
    if day != today:
        events = []

    # Try to parse events; if anything is invalid, assume no events
    busy_intervals = []
    try:
        for e in events:
            start = to_minutes(e["start"])
            end = to_minutes(e["end"])
            if start >= end:
                raise ValueError
            busy_intervals.append((start, end))
    except Exception:
        busy_intervals = []

    busy_intervals.sort(key=lambda x: x[0])

    available_starts = []
    current_time = WORK_START

    for start, end in busy_intervals:
        while current_time + meeting_duration <= min(start, WORK_END):
            available_starts.append(to_time_str(current_time))
            current_time += 1

        if current_time < end:
            current_time = max(current_time, end)

    while current_time + meeting_duration <= WORK_END:
        available_starts.append(to_time_str(current_time))
        current_time += 1

    return available_starts
```

---

If you want, I can:

* Add **unit tests** for all these edge cases
* Change granularity (e.g., 5-min or 15-min steps)
* Make â€œtodayâ€ injectable for easier testing

Just say the word ðŸ‘

--------------------------------------------------
--------------------------------------------------
Prompt 2: "Copy paste your question"
LLM Response 2: "Copy paste LLMs response"
--------------------------------------------------

--------------------------------------------------
Prompt 2: "Copy paste your question"
LLM Response 2: "Copy paste LLMs response"
--------------------------------------------------

--------------------------------------------------
Prompt 2: "Copy paste your question"
LLM Response 2: "Copy paste LLMs response"
--------------------------------------------------

--------------------------------------------------
Prompt 2: "Copy paste your question"
LLM Response 2: "Copy paste LLMs response"
--------------------------------------------------